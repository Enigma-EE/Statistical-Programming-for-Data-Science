


# assign a value ---------------------------------------------------------------

x <- 2 

x = 3

2 -> x


# don't forget to use comments

# don't forget to save the code

# use good variable names


dataToAnalyse <- rnorm(100)

data.to.analyse <- rnorm(100)

data_to_analyse <- rnorm(100)



# poor example

df <- data.frame(x = rnorm(100))



# Data types -------------------------------------------------------------------

x <- "test"

class(x)

typeof(x)


x <- 123

x <- 123L

x <- TRUE   # or FALSE

x

is.integer(x)

is.character(x)

is.logical(x)


x 

as.integer(x)

as.character(x)







# Data structures --------------------------------------------------------------

## vector ----


x <- "test"

length(x)

x <- c("Python", "Java", "SQL", "R")

length(x)

nchar(x)



y <- 1:6

y

length(y)

y * 2



y <- c(y, 99)

y

y + 100



y <- c(y, "R")

y



x

x <- c(x, 99, TRUE)

x


# indexing

x[1]

x[1:3]

x[c(1,3,5)]


# attributes

length(x)

names(x)

names(x) <- c("a", "b", "c", "d", "e", "f")

x

x["d"]

x[4]



attributes(x)


dim(x)

dim(x) <- c(2,3)

x


## matrix ----

z <- matrix(seq(1:12), nrow = 3, ncol = 4)

z

z^2

# indexing

z[1,4]

z[2, ]

z[ , 2]

z[1:2, 2:4]

z[c(1,3), c(2,4)]




## array ----

x <- 1:12

x

dim(x) <- c(2,3,2)

x

# indexing

x[1,2,1]

x[ , 1, ]

x[2, , 2]



array(letters, dim = c(2,3,2,2))



## list ----


x <- list(1:5, 2.5, "abcdef", TRUE)

x



x <- list(element1 = 1:5, element2 = 2.5, element3 = "abcdef", element4 = TRUE)

x


# indexing

x[[1]]

x$element1

x[["element1"]]

x["element1"]



length(x[["element1"]])

length(x["element1"])


x[[2]]

x[2]




## data frame ----

df <- data.frame(id = letters[1:10], x = 1:10, y = 11:20)

df

dim(df)

names(df)

class(df)

typeof(df)


# indexing

df[1,1]

df[ , 1]

df[1, ]

df$id

df[["id"]]

df["id"]


df[ , c(1,3)]

df[ , c("id", "y")]



df$new <- 0
df


df$new10 <- df$x * 10
df


df$new <- NULL
df


## factors ----

x <- rep(c("good", "bad", "ugly"), 3)
x

class(x)

x.f <- factor(x)
x.f

class(x.f)

as.numeric(x)

as.numeric(x.f)

x.f <- factor(x, levels = c("ugly", "bad", "good"))
x.f
as.numeric(x.f)


# logical indexing

x <- 1:8
x

x > 4

y <- letters[x]
y

y[x > 4]



df <- mtcars

head(df)

dim(df)

df.am1 <- df[df$am == 1, ]
df.am1


df.am1.cyl4 <- df[df$am == 1 & df$cyl < 5, ]
df.am1.cyl4





# Logical values or boolean values ---------------------------------------------

x <- 10

x > 5

x >= 10

x != 5

(x < 20) & (x > 5)



# Control flow operators - conditions ------------------------------------------

# if 


x <- 10

if(x > 5) {                # condition
  print("run code")        # statement
}




# if-else


x <- 3

if(x > 5) {                # condition
  print("run code")        # statement
} else {
  print("another code")    # alternative statement
}



# if - else - if

x <- 20

if(x > 100){
  print("very large number")
} else if(c > 10){
  print("medium range number")
} else {
  print("small number")
}




# function ifelse()

x <- 3
ifelse(x > 10, "large", "small")



# function switch()


x <- "one"

switch(x, "one" = 1, "two" = 2, "three" = 3, "check spelling")




x <- 2

switch(x, "one", "two", "three", "too long to type")


####







# Control flow operators - loops -----------------------------------------------

rm(list = ls())


# loop for

for(i in 1:10){
  print(i)  
}




x <- c("one", "two", "three")
for(i in x){
  print(i)
}




for(i in seq(1, length(x))){
  print(i)
  print(x[i])
  print("====")
}



# loop while


x <- 5
while(x > 0){       # condition to check
  print(x)          # statement to run
  x <- x - 1
}




# loop repeat

repeat{             # no condition or iterator
  print(x)
}




# operator break

x <- 1
repeat{
  print(x)
  x <- x + 1
  if(x > 10)
    break
}



x <- 1
while(x <= 10){
  print(x)
  x <- x + 1
  if(x == 8) break
}




x <- c("one", "two", "three", "four")
for(i in x){
  print(i)
  if(nchar(i) > 4){
    result <- i
    break
  }
}






# Functions --------------------------------------------------------------------


rm(list = ls())


# build-in functions

x <- c(3, 15, 7, 22)

y <- ifelse(x > 10, "large", "small")





x <- rnorm(100)

x

hist(x)


sum(x)


help(sum)




# User-defined functions

do_division <- function(x, y){
  temp <- x / y
  return(temp)
}




do_division(14, 7)


do_division(7, 14)


do_division(x = 14, y = 7)


do_division(y = 7, x = 14)



do_division <- function(x, y = 2){
  temp <- x / y
  return(temp)
}

do_division(14, 7)

do_division(14)




# anonymous functions


m <- matrix(rnorm(12), ncol = 4, nrow = 3)

m


apply(m, 2, sum)


apply(m, 2, function(x) round(max(x) - min(x), 2))



rounded_range <- function(x){
  temp <- max(x) - min(x)
  temp <- round(temp, 2)
  return(temp)
}

apply(m, 2, rounded_range)




####




# Packages ---------------------------------------------------------------------



?ifelse


help(package="base")


x <- 3
ifelse(x > 10, "large", "small")


library(dplyr)


x <- 3
if_else(x > 10, "large", "small")




install.packages("beepr")


beepr::beep(3)

for( i in seq(1:10)){
  beepr::beep(i)
}

beepr::beep(19)
































